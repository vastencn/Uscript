next do approx equal to!

introducing real numbers, fraction and variables as categories of "numbers"

variables, or "wave-numbers" are like using a,b,c,...x,y,z as variables, except that that are wave-1, wave-2, wave-3, etc..

Micro/Mega Nano/Giga
I don't use kilo or milli because they mean 1000
nano micro mega and giga are just words<
They mean dwarf/small/great/giant
But the name is only in the markup language
these words are not part of Uscript
so it doesn't really matter i guess


<todo>
add definition of mega/micro/etc..

refine approx to mean rounded to hex digit

if you want to do a tolerance then use tolerance. approx is a SPECIFIC thing. it means rounded to the most precise digit given

clarify how to specific precision on the left side of radix
</todo>

*show*
int frac var :: int frac and var types
wave :: wave/undefined/uncertain how vars work

absolute :: absolute, absequal :: absolute equal, != :: !=
gt lt :: > < gt/lt.by how much. not just bool

_2 :: micro/mega/nano/giga<br>shift the radix in increments of 32 places<br>we already have nice scinote symbols for shifting.<br>these prevent the need for large exponent scinote<br>.<br>with scinote+ and scinote- the 4 bit range is 32 radix points<br>hex: 5 scinote+22 = 5 mega scinote+2<br>hex: 3 scinote+1e = 3 mega scinote-2

mega = 1 _2 sci+32 :: mega = 1 scinote+32(1*16^32)
giga = 1 _2 sci+64 :: mega = 1 scinote+64(1*16^64)

 _2 :: this gives easy number expressions to of scales<br>Particularly important for physical units<br>Think of it like this...<br>we use scinote to cover a big range<br> 0.0000 0000 0000 0000 1 -> 1 0000 0000 0000 0000<br><br>beyond that the scinote symbol gets long<br>and powers that large are hard to comprehend<br>so we use micro/mega/nano/giga to jump into the other ranges

sci+1000 :: you can still use arbitrarily long scinote<br>if you insist

micro :: micro (hex 10^-20) , mega :: mega(hex 10^20)

nano :: nano(hex 10^-40) , giga :: giga(hex 10^40)