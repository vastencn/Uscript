<todo>
clarify that some symbols violate linear sequence
inv(-) or property name like charge/mass etc.. are prefix to a value, so they essentially create a bracket. this should be clarified explicitly

I'm going to assume the array sub contains  has be retroactively added to previous pages
need to do this later haha

currently you can treat something as an array and use array ops on it 

could add "array op types" based on the various subtypes. add the radical prefixes to tghe array ops like "sub-element-selector" could tag on the "taxonomy" or "part" radical. that would clarify context, not change function function. it would just make clear "we are treating a taxonomy or structure as an array to use the array handling tools for language".

That could help clarify context
and its easy to do in writing because I just tag on the radical symbol, like a prefix.

but its a bit more cumbersome to add it here in the system, so ill wait for now. I think its ok to just tread something as an array and expect the context to be clear, obviously there is a fundamental difference between an array of number and an array of physical particle within a proton or atom. but at some pointing higher level language it will be needed. I'm just procrastinating for now cause i wanna play with other things.
</todo>

introduce more properties like charge and spin

add some refinements to array descriptive and handling tools

instead of just listing the properties of each particle, we will take this opportunity to start "talking about things". using some of the tools for arrays we can say things like 

"all quarks have mass greater than 1"

to do this we use
"quark array-condition-all[mass > 1] = true"

which is a structure already defined to translate into procedural code
"{ foreach(quark) { last-result && (this-quark[mass] > 1); } return chained result; }

Also, and more importantly the sub-[ expression has been as an ambiguous hierarchy symbol.  

x subcup(y) means many things 
"y is a category of x"
"y is a component of x"
"y is true under x conditions"

We need to start explicitification(yes, that's, I was as surprised as you, it feels made up)

now that we have physical things composed of each other, and categories to group them into, plus procedural for conditions, we can now create differentiated version of the sub() structure

we will keep the ambiguous version. it can be handy. 

so subcup() has 4 subtypes now
conditional (implies/causes)
taxonomical (subtype of)
mereological (composition of)
qualitative (properties of) 

taxonomy :  "x subcat(y)", y is astronomically under x. doesnt matter how many layers, because you could always introduce new arbitrary category layers. 

as for : asking "how many layers down?", is directly under/above?" "etc, these questions are for another day.



*show*
charge :: charge , spin :: spin
_2 :: . <br>added sub-types of quarks and leptons<br>Did this to create good example of taxonomy 

utypequark :: up typequark , dtypequark :: down type quark
chargedlepton :: charged lepton , neutrino :: neutrino

_2 ::  . <br>here the ambiguous sub() gets sub-types<br> the unspecified subcup() is ambiguous<br>.<br>these new 3 are explicit<br>taxonomy vs. composition vs. condition<br>conditional is done with procedural<br>particles have "composite objects" and "categories"<br>so now its easy to distinguish these ideas<br><br>radicals use for these new sub types are not fully defined yet.<br>but thats not necesarry.<br>plus these use cases help establish their lexical scope.<br><br>"hierarchical" radical for taxonomy<br>"system" radical with "system particle" selected for composition<br>"conditional" uses the sub component of the procedural "IF bracket"<br>"property" uses "interaction" radical (how something interacts)

issubof :: is-sub-of , isparentof :: is-parent-of , subcup( _33 v_20 ) :: ambiguous 'sub'
iscatof :: is-cat-of , istypeof :: is-type-of, subcat ( _33 v_20 ) ::  subcat 
ismadeof :: is-made-of , ispartof :: is-part-of , subpart ( _33 v_20 ) ::  subpart
implies :: implies , impliedby :: implied-by , subif ( _33 v_20 ) ::  subif
hasprop :: has-property, ispropof :: is-property-of  , subprop ( _33 v_20 ) ::  subprop











