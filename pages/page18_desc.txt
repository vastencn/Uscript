<todo>
clarify that some symbols violate "linear operation sequence"
inv(-) or property name like charge/mass etc.. are prefix to a value, so they essentially create a bracket. this should be clarified explicitly
</todo>

introduce more properties like charge and spin

add some refinements to array descriptive and handling tools

instead of just listing the properties of each particle, we will take this opportunity to start "talking about things". using some of the tools for arrays we can say things like 

"all quarks have mass greater than 1"

to do this we use
"quark array-condition-all[mass > 1] = true"

which is a structure already defined to translate into procedural code
"{ foreach(quark) { last-result && (this-quark[mass] > 1); } return chained result; }

Also, and more importantly the sub-[ expression has been as an ambiguous hierarchy symbol.  

x subcup(y) means many things 
"y is a category of x"
"y is a component of x"
"y is true under x conditions"

We need to start explicitification(yes, that's, I was as surprised as you, it feels made up)

now that we have physical things composed of each other, and categories to group them into, plus procedural for conditions, we can now create differentiated version of the sub() structure

we will keep the ambiguous version. it can be handy. 

so subcup() has 4 subtypes now
conditional (implies/causes)
taxonomical (subtype of)
mereological (composition of)
qualitative (properties of) 

taxonomy :  "x subcat(y)", y is astronomically under x. doesnt matter how many layers, because you could always introduce new arbitrary category layers. 

as for : asking "how many layers down?", is directly under/above?" "etc, these questions are for another day.



*show*
charge :: charge<br>the electron is the uscript unit particle. mass and charge<br>giving it a negative charge was kind of 'historical mistake'<br>.<br>physical manifestations of electric discharge are asymmetric<br> and characterize by directional flow of electrons.<br>electrons are more mobile than protons so 'they are the fluid/movers'<br>When you see electric discharge. It's almost always electrons flowing<br>.<br>So uscript charge is 'inverted' compared to earths 'backwards legacy'.<br>I added 'negtron' as a synonym for 'proton' to help me with this.<br>I find 'proton' mnemonically triggers 'positive' for me

spin :: spin<br>yes. it was proposed to be physical 3d spin<br>because it produces orientation in 3d space<br>it was NOT that<br>but weirdly it is still a value used in equations of rotation<br><br>it was called spin incorrectly<br>but turned out be a different kind of 'spin quality'. funny huh.

_2 :: . <br>added sub-types of quarks and leptons<br>Did this to create good example of taxonomy 

utypequark :: up typequark , dtypequark :: down type quark
chargedlepton :: charged lepton , neutrino :: neutrino

_2 ::  . <br>here the ambiguous sub() gets important sub-types<br> the unspecified subcup() is ambiguous<br>.<br>these new 4 are explicit<br>taxonomy vs. composition vs. condition vs. property<br>conditional is done with procedural<br>particles have "composite objects" and "categories"<br>so now its easy to distinguish these ideas<br><br>radicals use for these new sub types are not fully defined yet.<br>but thats not necesarry.<br>plus these use cases help establish their lexical scope.<br><br>"hierarchical" radical for taxonomy<br>"system" radical with "system particle" selected for composition<br>"conditional" uses the sub component of the procedural "IF bracket"<br>"property" uses "interaction" radical (how something interacts)<br>.<br>This is just first introduction<br>they will become more clearly defined going forward<br>atoms/molecules/etc will all help clarify these defintions

issubof :: is-sub-of , isparentof :: is-parent-of , subcup( _33 v_20 ) :: ambiguous 'sub'
iscatof :: is-cat-of , istypeof :: is-type-of, subcat ( _33 v_20 ) ::  subcat 
ismadeof :: is-made-of , ispartof :: is-part-of , subpart ( _33 v_20 ) ::  subpart
implies :: implies , impliedby :: implied-by , subif ( _33 v_20 ) ::  subif
hasprop :: has-property, ispropof :: is-property-of  , subprop ( _33 v_20 ) ::  subprop











