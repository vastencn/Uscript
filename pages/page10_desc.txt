set symbols
sub/superset
overlap, no overlap

tolerance
array pop
bool varsets

<todo>
add set symbols definitions

add popping empty array and referencing non-existent array elemetnts. add it to later pages where undefined/wave has be estalished</todo>


tolerance here means "deviation must be less than" not "deviation acceptable up to".

pops will serve well as the idea of "taking from" later

establish that a unilateral varset operation can be evaluated and check. its value is equal to resulting new value of the variable.

bool ops can be used with varset the op using the establish patterns
might need more examples, but the patter is clear i think

<todo>
**should probably add invert-array symbol(rotate-array)

**add other form of tolerance deviation up to and including)

**add examples of tolerance where numbers are drawn above or below to manipulate the upper and lower bounds independently
</todo>

5 tolerance 2 include 3.0000001 but does not include 3 or 7

all/non/etc... these benefit more form expression variables which come later

<todo>
Add defintion that declare "a larger number contains a smaller number" using has. this is the behavior if the checked input is not an array. this way it can be abstracted better into linguistic usage.
</todo> 


*show*
tol :: tolerance
has( true true true  .. _5 false ) :: ... has o , isin (false .. true true true ) :: o is in ...
nhas( true true true  .. _5 false ) :: ... doesn't have o , nisin (false .. true true true ) :: o is not in ...

 _2 :: the has/isin search for elements in an array.<br>it means "array A has element B"<br>"array A has array B" checks if an element of A IS the array B<br>You can put comparator and formula in has/isnin braks<br>eg. A has > 5 <br>or A has [1] = 5 (any A[*][1] = 5)<br>.<br>Set theory operators compare 2 arrays to each other

supersetof :: superset of , subsetof :: subset of , setoverlap :: set overlap , nosetoverlap :: no set overlap

popa :: pop first array element, apop :: pop last array element


andleft :: and left. L = L and R, orleft :: or left . L = L or R 